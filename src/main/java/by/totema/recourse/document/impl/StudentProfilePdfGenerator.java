package by.totema.recourse.document.impl;

import by.totema.recourse.entity.dto.ErrorMessage;
import by.totema.recourse.entity.model.Employee;
import by.totema.recourse.repository.EmployeeRepository;
import by.totema.recourse.service.exception.ServiceNotFoundException;
import com.itextpdf.text.Document;
import com.itextpdf.text.Paragraph;

import java.util.Date;
import java.util.List;

import static by.totema.recourse.util.RepositoryCallWrapper.wrapJPACall;

public class StudentProfilePdfGenerator extends AbstractPdfGenerator {

    private final EmployeeRepository employeeRepository;

    private Employee student;
    private List<CourseFullInfo> courses;
    private Double averageMark;

    public StudentProfilePdfGenerator(
            EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }

    @Override
    public void loadDataById(Integer id) {
        wrapJPACall(() -> {
            student = employeeRepository.findOne(id);
            checkStudentValidity(student);
            final Double[] averageResultMark = {0.0};
            /*courses = student.getCourses().stream().map(course -> {
                List<Lesson> lessons = lessonRepository.findByCourseIdOrderByStartTimeAsc(course.getId(), allItemsPage());
                final Double[] averageMark = {0.0};
                List<LessonFullInfo> lessonInfos = lessons.stream().map(lesson -> {
                    Mark mark = markRepository.findByLessonIdAndStudentId(lesson.getId(), student.getId());
                    if (mark != null) {
                        averageMark[0] = averageMark[0] + mark.getScore();
                    }
                    return new LessonFullInfo(lesson, mark);
                }).collect(Collectors.toList());*
                averageMark[0] = (lessonInfos.isEmpty()) ? null : (averageMark[0] / lessonInfos.size());
                averageResultMark[0] = averageResultMark[0] + (averageMark[0] == null ? 0.0 : averageMark[0]);
                return new CourseFullInfo(course, lessonInfos, averageMark[0]);
            }).collect(Collectors.toList());
            averageMark = courses.isEmpty() ? null : (averageResultMark[0] / courses.size());*/
        });
    }

    private void checkStudentValidity(Employee student) {
        if (student == null || student.getRole() != Employee.Role.ADMIN) {
            throw new ServiceNotFoundException(new ErrorMessage("student", "Student not found"));
        }
    }

    @Override
    protected void addMetaData(Document document) {
      //  document.addTitle(String.format("%s %s Profile", student.getName(), student.getSurname()));
        document.addSubject("Student profile");
        document.addKeywords("Student, ReCourse, PDF, iText");
        document.addAuthor("Trium Group");
        document.addCreator("Trium Group");
    }

    @Override
    protected void addTitle(Document document) {
        Paragraph preface = new Paragraph();
        // We add one empty line
        addEmptyLine(preface, 1);
        // Lets write a big header
        //preface.add(new Paragraph(String.format("%s %s Profile", student.getName(), student.getSurname()), CAT_FONT));

        addEmptyLine(preface, 1);
        // Will create: Report generated by: _name, _date
        preface.add(new Paragraph(
                "Report for: " + new Date(), //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
                SMALL_BOLD));


    }

    @Override
    protected void addContent(Document document) {

    }

    private static class CourseFullInfo {
       /* Course course;
        List<LessonFullInfo> lessons;
        Double averageMark;

        CourseFullInfo(Course course, List<LessonFullInfo> lessons, Double averageMark) {
            this.course = course;
            this.lessons = lessons;
            this.averageMark = averageMark;
        }*/
    }

    private static class LessonFullInfo {
       /* Lesson lesson;
        Mark mark;

        public LessonFullInfo(Lesson lesson, Mark mark) {
            this.lesson = lesson;
            this.mark = mark;
        }*/
    }
}